'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteVideo = exports.LocalVideo = exports.WebRTCEvents = exports.WebRTCConstants = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _keymirror = require('keymirror');

var _keymirror2 = _interopRequireDefault(_keymirror);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebRTCConstants = exports.WebRTCConstants = (0, _keymirror2.default)({
  WEB_RTC_ON_LOCAL_AUDIO: null,
  WEB_RTC_ON_LOCAL_VIDEO: null,
  WEB_RTC_ON_SESSION_CREATED: null,
  WEB_RTC_ON_REMOTE_PARTICIPANT_JOINED: null,
  WEB_RTC_ON_SESSION_CONNECTED: null,
  WEB_RTC_ON_REMOTE_VIDEO: null,
  WEB_RTC_ON_REMOTE_PARTICIPANT_LEFT: null,
  WEB_RTC_ON_SESSION_ENDED: null,
  WEB_RTC_ON_CONNECTION_ERROR: null,
  WEB_RTC_ON_NOTIFICATION_RECEIVED: null,
  WEB_RTC_ON_AUDIO_MUTE: null,
  WEB_RTC_ON_VIDEO_MUTE: null,
  WEB_RTC_ON_DOMINANT_SPEAKER_CHANGED: null
});

var WebRTCEvents = exports.WebRTCEvents = function (_EventEmitter) {
  _inherits(WebRTCEvents, _EventEmitter);

  function WebRTCEvents(props) {
    _classCallCheck(this, WebRTCEvents);

    return _possibleConstructorReturn(this, (WebRTCEvents.__proto__ || Object.getPrototypeOf(WebRTCEvents)).call(this, props));
  }

  _createClass(WebRTCEvents, [{
    key: 'emitWebRTCEvent',
    value: function emitWebRTCEvent(eventType, event) {
      this.emit(eventType, event);
    }
  }, {
    key: 'addWebRTCListener',
    value: function addWebRTCListener(eventType, callback) {
      this.on(eventType, callback);
    }
  }, {
    key: 'removeWebRTCListener',
    value: function removeWebRTCListener(eventType, callback) {
      this.removeListener(eventType, callback);
    }
  }]);

  return WebRTCEvents;
}(_events.EventEmitter);

var LocalVideo = exports.LocalVideo = function (_React$Component) {
  _inherits(LocalVideo, _React$Component);

  function LocalVideo(props) {
    _classCallCheck(this, LocalVideo);

    var _this2 = _possibleConstructorReturn(this, (LocalVideo.__proto__ || Object.getPrototypeOf(LocalVideo)).call(this, props));

    console.log('in constructor of localVideo');
    console.log(_this2.props);
    return _this2;
  }

  _createClass(LocalVideo, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.props.video.track.attach($(this.refs.localVideo)[0]);
      this.props.audio.track.attach($(this.refs.localAudio)[0]);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.props.video.track.detach($(this.refs.localVideo)[0]);
      this.props.audio.track.detach($(this.refs.localAudio)[0]);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        null,
        this.props.video ? _react2.default.createElement('video', { ref: 'localVideo', autoPlay: '1', id: 'localVideo' + this.props.video.index, src: this.props.video.src }) : null,
        this.props.audio ? _react2.default.createElement('audio', { ref: 'localAudio', autoPlay: '1', muted: 'true', id: 'localAudio' + this.props.audio.index, src: this.props.audio.src }) : null
      );
    }
  }]);

  return LocalVideo;
}(_react2.default.Component);

var RemoteVideo = exports.RemoteVideo = function (_React$Component2) {
  _inherits(RemoteVideo, _React$Component2);

  function RemoteVideo(props) {
    _classCallCheck(this, RemoteVideo);

    return _possibleConstructorReturn(this, (RemoteVideo.__proto__ || Object.getPrototypeOf(RemoteVideo)).call(this, props));
  }

  _createClass(RemoteVideo, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        null,
        this.props.video ? _react2.default.createElement('video', { autoPlay: '1', id: this.props.video.index, src: this.props.video.src }) : null,
        this.props.audio ? _react2.default.createElement('audio', { autoPlay: '1', id: this.props.audio.index, src: this.props.audio.src }) : null
      );
    }
  }]);

  return RemoteVideo;
}(_react2.default.Component);

exports.default = function (ComposedComponent) {
  return function (_React$Component3) {
    _inherits(WebRTCBase, _React$Component3);

    function WebRTCBase(props) {
      _classCallCheck(this, WebRTCBase);

      var _this4 = _possibleConstructorReturn(this, (WebRTCBase.__proto__ || Object.getPrototypeOf(WebRTCBase)).call(this, props));

      _this4.state = {
        xrtcSDK: null,
        roomName: null,
        irisRtcConn: null,
        localRtcStream: null,
        session: null,
        userConfig: null,
        isAudioMuted: false,
        isVideoMuted: false,
        localConnectionList: [],
        remoteConnectionList: [],
        chatMessageHistory: []
      };

      _this4.localTracks = [];
      _this4.remoteTracks = [];
      _this4.eventEmitter = new WebRTCEvents();
      return _this4;
    }

    _createClass(WebRTCBase, [{
      key: '_initializeWebRTC',
      value: function _initializeWebRTC(userName, routingId, roomName, domain, hosts, token) {
        var resolution = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '640';

        console.log('initializeWebRTC -> userName ' + userName);
        console.log('initializeWebRTC -> routingId ' + routingId);
        console.log('initializeWebRTC -> roomName ' + roomName);
        console.log('initializeWebRTC -> domain ' + domain);
        console.log('initializeWebRTC -> resolution ' + resolution);
        console.log(hosts);

        var traceId = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
          var r = Math.random() * 16 | 0,
              v = c == 'x' ? r : r & 0x3 | 0x8;return v.toString(16);
        });
        var userConfig = {
          jid: userName,
          password: '',
          roomName: roomName,
          domain: domain,
          token: token,
          routingId: routingId + '@' + domain,
          anonymous: false,
          traceId: traceId,
          useEventManager: true,
          callType: 'videocall',
          loginType: 'connect',
          resolution: resolution,
          eventManager: hosts.eventManagerUrl,
          notificationManager: hosts.notificationServer,
          UEStatsServer: ''
        };
        var serverConfig = userConfig;
        console.log("init SDK");
        console.log(userConfig);
        var xrtcSDK = IrisRtcSdk;
        console.log(xrtcSDK);
        xrtcSDK.init(serverConfig);
        this.setState({
          xrtcSDK: xrtcSDK,
          userConfig: userConfig,
          roomName: roomName
        });

        console.log(userConfig);

        // create connection
        this.state.irisRtcConn = new xrtcSDK.Connection();
        this.state.irisRtcConn.onConnectionError = this._onConnectionError.bind(this);
        this.state.irisRtcConn.connect(userConfig.token, userConfig.routingId);

        if (xrtcSDK != null) {
          xrtcSDK.onConnected = this._onConnected.bind(this);
          xrtcSDK.onSessionJoined = this._onSessionJoined.bind(this);
          xrtcSDK.onSessionEnd = this._onSessionEnd.bind(this);
          xrtcSDK.onSessionParticipantLeft = this._onSessionParticipantLeft.bind(this);
          xrtcSDK.onSessionParticipantJoined = this._onSessionParticipantJoined.bind(this);
          xrtcSDK.onRemoteStream = this._onRemoteStream.bind(this);
          xrtcSDK.onUserJoined = this._onUserJoined.bind(this);
          xrtcSDK.onChatMsgReceived = this._onChatMsgReceived.bind(this);

          xrtcSDK.onLocalAudio = this._onLocalAudio.bind(this);
          xrtcSDK.onLocalVideo = this._onLocalVideo.bind(this);
          xrtcSDK.onSessionCreated = this._onSessionCreated.bind(this);
          xrtcSDK.onRemoteParticipantJoined = this._onRemoteParticipantJoined.bind(this);
          xrtcSDK.onSessionConnected = this._onSessionConnected.bind(this);
          xrtcSDK.onRemoteVideo = this._onRemoteVideo.bind(this);
          xrtcSDK.onRemoteParticipantLeft = this._onRemoteParticipantLeft.bind(this);

          xrtcSDK.onConnectionError = this._onConnectionError.bind(this);
          xrtcSDK.onNotificationReceived = this._onNotificationReceived.bind(this);
          xrtcSDK.onDominantSpeakerChanged = this._onDominantSpeakerChanged.bind(this);
        }
      }
    }, {
      key: '_sendChatMessage',
      value: function _sendChatMessage(userId, message) {
        console.log('Sending message from ' + userId + ' in _sendChatMessage saying: ' + message);
        this.state.session.sendChatMessage(message);
      }
    }, {
      key: '_onChatMsgReceived',
      value: function _onChatMsgReceived(userUrl, message, timestamp) {
        console.log('Received chat message from: ' + userUrl + ' saying: ' + message + ' at: ' + timestamp);
        var routingId = userUrl.substring(0, userUrl.indexOf("@"));

        // add to chat history whenever we receive a message from remote participants
        this.setState({ chatMessageHistory: this.state.chatMessageHistory.concat([{ routingId: routingId, message: message }]) });
      }
    }, {
      key: '_onDominantSpeakerChanged',
      value: function _onDominantSpeakerChanged(dominantSpeakerEndpoint) {
        console.log('onDominantSpeakerChanged' + dominantSpeakerEndpoint);
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_DOMINANT_SPEAKER_CHANGED, dominantSpeakerEndpoint);
      }
    }, {
      key: '_sessionEnd',
      value: function _sessionEnd() {
        if (this.state.xrtcSDK) {
          var tracks = this.state.localRtcStream.getLocalTracks();

          tracks.forEach(function (t) {
            t.dispose();
          });

          this.state.session.endSession();
          this.setState({ localRtcStream: null, localConnectionList: [], remoteConnectionList: [] });
        }
      }
    }, {
      key: '_onSessionParticipantLeft',
      value: function _onSessionParticipantLeft(pid) {
        console.log('_onSessionParticipantLeft');
        console.log(pid);
        this._onRemoteParticipantLeft(pid);
      }
    }, {
      key: '_onSessionParticipantJoined',
      value: function _onSessionParticipantJoined(remoteUserInfo) {
        console.log('_onSessionParticipantJoined');
        console.log(remoteUserInfo);
      }
    }, {
      key: '_onSessionError',
      value: function _onSessionError(error) {
        console.log(error);
      }
    }, {
      key: '_onSessionJoined',
      value: function _onSessionJoined() {
        console.log('in _onSessionJoined');
      }
    }, {
      key: '_onConnectionError',
      value: function _onConnectionError(error) {
        console.log(error);
      }
    }, {
      key: '_onConnected',
      value: function _onConnected() {
        console.log('_onConnected');

        this.setState({ chatMessageHistory: [] });

        // create local stream
        this.state.localRtcStream = new this.state.xrtcSDK.Stream();
        var localStream = this.state.localRtcStream.createStream('video');
        console.log('localStream:');
        console.log(localStream);
        this.state.xrtcSDK.onLocalStream = this._onLocalStream.bind(this);
      }
    }, {
      key: '_onLocalStream',
      value: function _onLocalStream(localTracks) {
        console.log('_onLocalStream');
        console.log(localTracks);

        // create session
        var session = new this.state.xrtcSDK.Session();
        session.onSessionError = this._onSessionError.bind(this);
        session.createSession(localTracks, "", { roomId: this.state.roomName });

        this.setState({ session: session });

        // render local track
        this._onLocalVideo('1234', localTracks);
      }
    }, {
      key: '_onRemoteStream',
      value: function _onRemoteStream(remoteTracks) {
        console.log('_onRemoteStream');
        console.log(remoteTracks);
        this._onRemoteVideo(remoteTracks.sid, remoteTracks);
      }
    }, {
      key: '_onUserJoined',
      value: function _onUserJoined(id, participant) {
        console.log('_onUserJoined');
        console.log(id);
        console.log(participant);
      }
    }, {
      key: '_onWebRTCConnect',
      value: function _onWebRTCConnect(response) {
        console.log('createSession callback');
        console.log(response);
      }
    }, {
      key: '_onLocalAudio',
      value: function _onLocalAudio() {
        console.log('onLocalAudio');
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_LOCAL_AUDIO);
      }
    }, {
      key: '_onLocalVideo',
      value: function _onLocalVideo(sessionId, tracks) {
        var _this5 = this;

        console.log('onLocalVideo');
        console.log(sessionId);
        console.log(tracks);

        this.localTracks = tracks;
        var localConnectionList = this.state.localConnectionList;
        var audioConnection = null;
        var videoConnection = null;

        for (var i = 0; i < this.localTracks.length; i++) {
          if (this.localTracks[i].getType() == "video") {
            //this.localTracks[i].attach("");
            videoConnection = {
              index: i,
              src: this.localTracks[i].stream.jitsiObjectURL,
              track: this.localTracks[i]
            };
          } else {
            //this.localTracks[i].attach("");
            audioConnection = {
              index: i,
              src: this.localTracks[i].stream.jitsiObjectURL,
              track: this.localTracks[i]
            };
          }
          //this.state.xrtcSDK.addTrack(this.localTracks[i]);
        }
        localConnectionList.push({
          video: videoConnection,
          audio: audioConnection
        });
        this.setState({
          localConnectionList: localConnectionList
        }, function () {
          _this5.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_LOCAL_VIDEO, {
            sessionId: sessionId,
            tracks: tracks
          });
        });
      }
    }, {
      key: '_onSessionCreated',
      value: function _onSessionCreated(sessionId, roomName) {
        console.log('onSessionCreated - session created with ' + sessionId + ' and user joined in ' + roomName);
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_SESSION_CREATED, {
          sessionId: sessionId,
          roomName: roomName
        });
      }
    }, {
      key: '_onRemoteParticipantJoined',
      value: function _onRemoteParticipantJoined() {
        console.log('onRemoteParticipantJoined');
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_REMOTE_PARTICIPANT_JOINED);
      }
    }, {
      key: '_onSessionConnected',
      value: function _onSessionConnected() {
        console.log('onSessionConnected');
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_SESSION_CONNECTED);
      }
    }, {
      key: '_onRemoteVideo',
      value: function _onRemoteVideo(sessionId, track) {
        var _this6 = this;

        console.log('onRemoteVideo ' + sessionId + ' track ' + track);

        var participant = track.getParticipantId();
        if (!this.remoteTracks[participant]) this.remoteTracks[participant] = [];
        var idx = this.remoteTracks[participant].push(track);
        var baseId = participant.replace(/(-.*$)|(@.*$)/, '');
        var id = baseId + track.getType();
        console.log('_onRemoteVideo ID: ' + id);

        var remoteConnectionList = this.state.remoteConnectionList;
        var audioConnection = null;
        var videoConnection = null;

        // check if the audio or video component for this base track
        // already exists
        var existingConnection = _underscore2.default.find(remoteConnectionList, function (obj) {
          return obj.baseId === baseId;
        });

        // if it does remove half populated connection and save the audio
        // or video part to be used with the new connection for this baseId
        if (existingConnection) {
          audioConnection = existingConnection.audio;
          videoConnection = existingConnection.video;
          remoteConnectionList = _underscore2.default.without(remoteConnectionList, existingConnection);
        }

        track.attach(id);
        if (track.getType() == "video") {
          console.log('onRemoteVideo video');
          videoConnection = {
            index: id,
            src: track.stream.jitsiObjectURL
          };
        } else {
          console.log('onRemoteVideo audio');
          audioConnection = {
            index: id,
            src: track.stream.jitsiObjectURL
          };
        }
        remoteConnectionList.push({
          video: videoConnection,
          audio: audioConnection,
          baseId: baseId,
          track: track
        });
        this.setState({
          remoteConnectionList: remoteConnectionList
        }, function () {
          if (videoConnection && audioConnection) {
            // notify only when both video and audio is available
            _this6.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_REMOTE_VIDEO, {
              sessionId: sessionId,
              track: track
            });
          }
        });
      }
    }, {
      key: '_onRemoteParticipantLeft',
      value: function _onRemoteParticipantLeft(id) {
        var _this7 = this;

        console.log('onRemoteParticipantLeft: ' + id);

        if (!this.remoteTracks[id]) {
          console.log('NO REMOTE TRACK FOUND');
          return;
        }

        var tracks = this.remoteTracks[id];

        var _loop = function _loop(i) {
          var baseId = id.replace(/(-.*$)|(@.*$)/, '');
          //tracks[i].detach(trackId);

          var remoteConnectionList = _this7.state.remoteConnectionList;
          var existingConnection = _underscore2.default.find(remoteConnectionList, function (obj) {
            return obj.baseId === baseId;
          });

          remoteConnectionList = _underscore2.default.without(remoteConnectionList, existingConnection);
          _this7.setState({
            remoteConnectionList: remoteConnectionList
          });
        };

        for (var i = 0; i < tracks.length; i++) {
          _loop(i);
        }

        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_REMOTE_PARTICIPANT_LEFT, id);
      }
    }, {
      key: '_onSessionEnd',
      value: function _onSessionEnd(sessionId) {
        console.log('onSessionEnded: ' + sessionId);
        if (this.state.xrtcSDK) {
          this.state.irisRtcConn.disconnect();
        }
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_SESSION_ENDED, sessionId);
      }
    }, {
      key: '_onConnectionError',
      value: function _onConnectionError(sessionId) {
        console.log('onConnectionError: ' + sessionId);
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_CONNECTION_ERROR, sessionId);
      }
    }, {
      key: '_onNotificationReceived',
      value: function _onNotificationReceived() {
        console.log('onNotificationReceived');
        this.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_NOTIFICATION_RECEIVED);
      }
    }, {
      key: '_onAudioMute',
      value: function _onAudioMute() {
        var _this8 = this;

        var isMuted = !this.state.isAudioMuted;
        this.setState({
          isAudioMuted: isMuted
        }, function () {
          _this8.state.localRtcStream.toggleAudioMute(isMuted, function (response) {
            if (!response) {
              console.log("Local audio mute/unmute failed");
              _this8.setState({
                isAudioMuted: !_this8.state.isAudioMuted
              });
            }
          });
          _this8.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_AUDIO_MUTE);
        });
      }
    }, {
      key: '_onVideoMute',
      value: function _onVideoMute() {
        var _this9 = this;

        var isMuted = !this.state.isVideoMuted;
        this.setState({
          isVideoMuted: isMuted
        }, function () {
          _this9.state.localRtcStream.toggleVideoMute(isMuted, function (response) {
            if (!response) {
              _this9.setState({
                isVideoMuted: !_this9.state.isVideoMuted
              });
            }
          });
          _this9.eventEmitter.emitWebRTCEvent(WebRTCConstants.WEB_RTC_ON_VIDEO_MUTE);
        });
      }
    }, {
      key: '_getRootNodeId',
      value: function _getRootNodeId() {
        if (this.state.xrtcSDK && this.state.xrtcSDK.connection && this.state.xrtcSDK.connection.options) {
          return this.state.xrtcSDK.connection.options.eventNodeId;
        }

        return null;
      }
    }, {
      key: '_getRootChildNodeId',
      value: function _getRootChildNodeId() {
        if (this.state.xrtcSDK && this.state.xrtcSDK.connection && this.state.xrtcSDK.connection.options) {
          return this.state.xrtcSDK.connection.options.eventCnodeId;
        }

        return null;
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(ComposedComponent, _extends({}, this.props, {
          params: this.props.params,
          initializeWebRTC: this._initializeWebRTC.bind(this),
          isWebRTCInitialized: this.state.xrtcSDK !== undefined && this.state.xrtcSDK !== null,
          onAudioMute: this._onAudioMute.bind(this),
          onVideoMute: this._onVideoMute.bind(this),
          localVideos: this.localVideos,
          remoteVideos: this.remoteVideos,
          getRootNodeId: this._getRootNodeId.bind(this),
          getRootChildNodeId: this._getRootChildNodeId.bind(this),
          endSession: this._sessionEnd.bind(this),
          addWebRTCListener: this.eventEmitter.addWebRTCListener.bind(this.eventEmitter),
          removeWebRTCListener: this.eventEmitter.removeWebRTCListener.bind(this.eventEmitter),
          sendChatMessage: this._sendChatMessage.bind(this),
          chatMessageHistory: this.state.chatMessageHistory
        }));
      }
    }, {
      key: 'localVideos',
      get: function get() {
        return this.state.localConnectionList ? this.state.localConnectionList : [];
      }
    }, {
      key: 'remoteVideos',
      get: function get() {
        return this.state.remoteConnectionList ? this.state.remoteConnectionList : [];
      }
    }]);

    return WebRTCBase;
  }(_react2.default.Component);
};